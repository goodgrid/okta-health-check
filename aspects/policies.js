import config from "../config.js";
import { oktaPublic } from "../oktaApi.js";
import { debug } from "../utils.js";

const labels = {
    password: {
        complexity: {
            minLength: "Minimum length",
            minLowerCase: "Minimum number of lower case characters",
            minUpperCase: "Minimum number of upper case characters",
            minNumber: "Minimum number of numbers",
            minSymbol: "Minimum number of symbols",
            excludeUsername: "May not contain username",
            dictionary: "Dictionary with too common passwords applied",
            excludeAttributes: "May not contain account attributes"
        },
        age: {
            maxAgeDays: "Days after which the password needs to be changed",          
            expireWarnDays: "Number of days in advance to warn for expiring password",
            minAgeMinutes: "Number of minutes password needs to be old before it can be changed again",
            historyCount: "Number of passwords that may not be reused"
        },
        lockout: {
            maxAttempts: "Maximum failed attempts before account is locked",
            autoUnlockMinutes: "Account automatically unlocks after (minutes)",
            userLockoutNotificationChannels: "Channel to notify user over about locked account",
            showLockoutFailures: "Show failures leading to account lock"
        }
    },
    zones: {
        ZONE: "Network zone",
        ANYWHERE: "Anywhere"
    },
    factorEnrollmentStrategies: {
        REQUIRED: "required",
        OPTIONAL: "optional",
        NOT_ALLOWED: "not alowed"
    }
}

const factorTypes = {
    okta_otp: {
        title: "Okta Verify with OTP",
        description: "This factor requires the user to enter a code generated by Okta Verify. Such a One-Time Password is verified based on a shared secret between the app and the Okta instance and is only valid for a limited amount of time. This factor assures to a reasonable level that the user has possession over a known physical token, the phone. Users need to be aware that the generated code serves as a password and needs to stay secret. OTP Fraud includes social engineering to obtain generated codes.",
    },
    okta_push: {
        title: "Okta Verify with Push",
        description: "This factor sends a notification to a known device requiring the user to confirm it is him/her attempting to log in. The response returned after confirmation is verified based on a shared secret between the app and the Okta instance and is only valid for a limited amount of time. This factor assures to a reasonable level that the user has possession over a known physical token, the phone. However, only requiring one-touch confirmation of a log-in attempt is vulnerable to so called 'MFA fatigue attacks where the user eventually confirms to stop endless MFA notifications."
    },
    showPushUpgradeNotification: {
        title: "showPushUpgradeNotification",
        description: ""
    },
    google_otp: {
        title: "Google Authenticator",
        description: "Google Authenticator is a popular authenticator app used to perform MFA based on one-time passwords. Such a One-Time Password is verified based on a shared secret between the app and the Okta instance and is only valid once or for a limited amount of time, depending on usage of the HOTP or TOTP standard. This factor assures to a reasonable level that the user has possession over a known physical token, the phone. Users need to be aware that the generated code serves as a password and needs to stay secret. Google Authenticator allows to export profiles from one phone and import them on another. This is user friendly, but weakens the possession factor it should be. Google Authenticator is sometimes critized for the of the SHA1 algorithm wich is no longer considered secure and for not protecting access to the app with biometric verification like FaceID, TouchID, etc. (https://securethoughts.com/google-authenticator/)"
    },
    oktaSms: {
        title: "Okta SMS Message",
        description: "This factor allows the user to confirm his/her identity by returning a code sent by Okta to the known mobile phone number which was previously verified. This increases assurance to a reasonable level. For higher confidence levens, this factor should be reviewed, since e-SIMs weaken the possession factor of a phone. Also, mobile operators may not have sufficient measures in place to prevent phone number hijacking."
    },

    oktaCall: {
        title: "Okta Phone Call",
        description: "This factor allows the user to confirm his/her identity by returning a code provided in a voice call by Okta to the known mobile phone number which was previously verified. This increases assurance to a reasonable level. For higher confidence levens, this factor should be reviewed, since e-SIMs weaken the possession factor of a phone. Also, mobile operators may not have sufficient measures in place to prevent phone number hijacking."
    },

    symantecVip: {
        title: "Symantec Validation and ID Protection Service",
        description: "Symantec VIP is a Multi Factor Authentication suite with options varying from an authenticator app to the use of hardware tokens. Depending on the choices made, the assurence is reasoable to very high."
    },
    rsaToken: {
        title: "RSA Token",
        description: ""
    },
    duo: {
        title: "Duo Token (Hardware)",
        description: ""
    },
    yubikey: {
        title: "Yubi Key (Hardware)",
        description: ""
    },
    onPremMFA: {
        title: "On Premise MFA Implementation",
        description: ""
    },
    oktaQuestion: {
        title: "Okta Security Question",
        description: "This Okta specific factor requires the correct answer to a previously set question. For example, favorite food as a child. This factor has not high assurence, but can be applied to avoid brute force attacks or to start a password reset procedure."
    },
    fidoWebauthn: {
        title: "FIDO2 Web Authentication",
        description: "WebAuthn is the core deliverable of the FIDO2 Project of the FIDO Alliance. As the successor of FIDO U2F, FIDO2 can be used as a single or second factor. Dependent on the implementation of this standard, the verification is baed on a knowledge factor, like a pin, password or swipe pattern, or a biometric factor, like fingerprint, iris, face or voice."
    },
    fidoU2f: {
        title: "FIDO U2F",
        description: "This is the predecessor of the FIDO2 standards. It is considered legacy."
    },
    oktaEmail: {
        title: "Okta E-mail Message",
        description: "This factor requires the return of a code sent to a previously verified email address. The assurance of this factor is completely dependent of the security of the email infrastructure and access to mailboxes."
    },
    customSAML: {
        title: "Custom SAML Challenge",
        description: "This factor allows for verification of users identities using a trusted identty provider using the SAML2 standard. This allows, for example, to confidently identify users using national eID schemes, as long as they support the SAML2 standard."
    },
    customOIDC: {
        title: "Custom OIDC Challenge",
        description: "This factor allows for verification of users identities using a trusted identty provider using the OpenID Connect standard. This allows, for example, to confidently identify users using national eID schemes, as long as they support the OIDC standard."
    },
    claimsProvider: {
        title: "Claims provider",
        description: ""
    },
    customHOTP: {
        title: "Custom HMAC-based OTP (HOTP) factor",
        description: "Okta is set up to support a custom HOTP authenticator."
    },
    hasVipCert: {
        title: "Extra: factor has VIP Certificate",
        description: ""
    },
    hasDuoConfig: {
        title: "Extra: factor has Duo Config",
        description: ""
    },
    hasRsaConfig: {
        title: "Extra: factor has RSA Config",
        description: ""
    },
    hasYubikeyConfig: {
        title: "Extra: factor has YUBI Config",
        description: ""
    },
    hasOnPremMFAConfig: {
        title: "Extra: factor has On Premise MFA Config",
        description: ""
    },
    hasCustomSAMLConfig: {
        title: "Extra: factor has Custom SAML Config",
        description: ""
    },
    hasCustomOIDCConfig: {
        title: "Extra: factor has Custom OIDC Config",
        description: ""
    },
    hasClaimsProviderConfig: {
        title: "Extra: factor has Claims Provider Config",
        description: ""
    },
    touchIDEnabledForOktaVerify: {
        title: "Extra: touch ID enabled (Okta Verify)",
        description: "The assurance of Okta Verify is strengtened by also requiting biometric based verification to the app, using TouchID/FaceID"
    },
    hardwareKeyStorageRequiredForOktaVerifyAndroid: {
        title: "Hardware Key storage required (Okta Verify)",
        description: ""
    },
    oktaVerifyNumberMatchingChallengeSupport: {
        title: "Matching number challenger support (Okta Verify)",
        description: ""
    },
    fipsRequiredForOktaVerify: {
        title: "FIPS Required (Okta Verify)",
        description: "Okta Verify is set to managed keys in accordance with FIPS 140-2. Federal Information Processing Standard (FIPS) directive 140-2 ensures that the management of cryptographic keys is in accordance with the NIST standards. Applying FIPS standards is a requirement for many US-based, regulated industries and US state and government agencies."
    },


}



const policyData = async (type) => {

    console.log(`Getting Policy Data`)

    const { data : policies } = await oktaPublic.get("policies",{
        params: {
            type: type
        }
    })

    return Promise.all(policies.map(async policy => {

        

        return {
            id: policy.id,    
            name: policy.name,
            description: policy.description,
            status: policy.status,
            appliesTo: await getGroupInfo(policy.conditions.people.groups.include),
            settings: makeSettingsReadable(type, policy.settings),

            "rules": await Promise.all((await oktaPublic.get(`policies/${policy.id}/rules`)).data.map(async rule => {

                return {
                    name: rule.name,
                    if: {
                        provider: (rule.conditions.identityProvider) ? rule.conditions.identityProvider.provider : "",
                        origin: `${labels.zones[rule.conditions.network.connection]} '${await getZoneInfo(rule.conditions.network.include)}'`,
                        context: "",
                        risk: "",
                        except: rule.conditions.people.users.exclude
                    },
                    then: makeRuleActionsReadable(type, rule.actions),
                    sortOrder: rule.priority
                }
    
            })),
            sortOrder: policy.priority
        }

    })
    .sort())

}

const makeRuleActionsReadable = (type, actions) => {
    
    if (type == "MFA_ENROLL") {
        switch (actions.enroll.self) {
            case "CHALLENGE":
                return { enrollment: "Self-enroll right before challenge" }
            case "LOGIN":
                return { enrollment: "Self-enroll while logging in" }
            case "NEVER":
                return { enrollment: "Don't self-enroll" }
        
            default: 
                return { enrollment: "Unknown enrollment" }
        }
    } else if (type == "OKTA_SIGN_ON") {
        
        return {
            access: actions.signon.access,
            factorRequired: actions.signon.requiresFactor,
            factorLifetime: actions.signon.factorLifetime,
            cookiePersistent: actions.signon.session.usePersistentCookie,
            maxSessionIdleMinutes: actions.signon.session.maxSessionIdleMinutes,
            maxSessionLifetimeMinutes: actions.signon.session.maxSessionLifetimeMinutes
        }

    }
}

const makeSettingsReadable = (type, settings) => {
    debug(`Creating readable policy settings for policy type ${type}`)

    if (type == "PASSWORD") { 
        return {
            password: {
                complexity: Object.getOwnPropertyNames(settings.password.complexity).map(setting => {
                    return `${labels.password.complexity[setting]}: ${settings.password.complexity[setting]}`
                    
                }),
                
                age: Object.getOwnPropertyNames(settings.password.age).map(setting => {
                    return `${labels.password.age[setting]}: ${settings.password.age[setting]}`
                    
                }),
                lockout: Object.getOwnPropertyNames(settings.password.lockout).map(setting => {
                    return `${labels.password.lockout[setting]}: ${settings.password.lockout[setting]}`
                    
                }),
                
            }
        }

    } else if (type == "MFA_ENROLL") {

        return {
            factorEnrollmentStrategies: Object.getOwnPropertyNames(settings.factors).map(factor => {
                return `Enrollment of factor ${factor} is ${labels.factorEnrollmentStrategies[settings.factors[factor].enroll.self]}.`
            })
        }

    }
}

const getGroupInfo = (groups) => {
    return Promise.all(groups.map(async group => {
        const { data : { profile : { name : groupName }}} = await oktaPublic.get(`groups/${group}`)
        return groupName
    }))
}

const getZoneInfo = (zones) => {
    if (zones !== undefined) {
        return Promise.all(zones.map(async zone => {
            switch (zone) {
                case "ALL_ZONES":
                    return "All zones"
                default: 
                    const { data: { name : zoneName }} = await oktaPublic.get(`zones/${zone}`)
                    return zoneName    
            }
        }))
    }
    return []
}

const getConnectionInfo = async (network) => {
    switch (network.connection) {
        case "ZONE":
            return `Zone XX`
        default:
            return "Unknown"
    }
}

export { policyData }